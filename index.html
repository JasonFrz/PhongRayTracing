<!DOCTYPE html>
<html>
<head>
  <title>Ray Tracing with Floor Shadow</title>
  <style>
    body { margin: 0; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = 800;
canvas.height = 600;

const width = canvas.width;
const height = canvas.height;
const MAX_DEPTH = 5;

class Vector {
  constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
  add(v) { return new Vector(this.x + v.x, this.y + v.y, this.z + v.z); }
  sub(v) { return new Vector(this.x - v.x, this.y - v.y, this.z - v.z); }
  mul(s) { return new Vector(this.x * s, this.y * s, this.z * s); }
  dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
  cross(v) {
    return new Vector(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }
  norm() { const m = Math.sqrt(this.dot(this)); return this.mul(1 / m); }
  reflect(n) { return this.sub(n.mul(2 * this.dot(n))); }
}

class Ray {
  constructor(origin, dir) {
    this.origin = origin;
    this.dir = dir;
  }
}

class Sphere {
  constructor(center, radius, color, specular, reflective) {
    this.center = center;
    this.radius = radius;
    this.color = color;
    this.specular = specular;
    this.reflective = reflective;
  }

  intersect(ray) {
    const oc = ray.origin.sub(this.center);
    const a = ray.dir.dot(ray.dir);
    const b = 2 * oc.dot(ray.dir);
    const c = oc.dot(oc) - this.radius * this.radius;
    const discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return null;
    const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
    const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
    const t = t1 > 0 ? t1 : (t2 > 0 ? t2 : null);
    if (t === null) return null;
    const point = ray.origin.add(ray.dir.mul(t));
    const normal = point.sub(this.center).norm();
    return { t, point, normal, object: this };
  }
}

class Plane {
  constructor(point, normal, color, specular, reflective) {
    this.point = point;
    this.normal = normal.norm();
    this.color = color;
    this.specular = specular;
    this.reflective = reflective;
  }

  intersect(ray) {
    const denom = this.normal.dot(ray.dir);
    if (Math.abs(denom) < 1e-6) return null;
    const t = this.point.sub(ray.origin).dot(this.normal) / denom;
    if (t < 0) return null;
    const point = ray.origin.add(ray.dir.mul(t));
    return { t, point, normal: this.normal, object: this };
  }
}

const objects = [
  new Sphere(new Vector(-1.5, 0.5, 6), 1, { r: 255, g: 0, b: 0 }, 100, 0.4),
  new Sphere(new Vector(1.5, 0.5, 7), 1, { r: 0, g: 0, b: 255 }, 500, 0.6),
  new Plane(new Vector(0, -1, 0), new Vector(0, 1, 0), { r: 200, g: 200, b: 200 }, 10, 0) // Lantai
];

const light = {
  position: new Vector(5, 5, -10),
  intensity: 1.0
};

function phongLighting(point, normal, view, specular) {
  const lightDir = light.position.sub(point).norm();
  let diffuse = Math.max(0, normal.dot(lightDir)) * light.intensity;

  let spec = 0;
  if (specular >= 0) {
    const reflect = lightDir.reflect(normal);
    const rdotv = Math.max(0, reflect.dot(view));
    spec = Math.pow(rdotv, specular) * light.intensity;
  }

  return { diffuse, specular: spec };
}

function trace(ray, depth) {
  if (depth > MAX_DEPTH) return { r: 0, g: 0, b: 0 };

  let closest = Infinity;
  let hit = null;

  for (const obj of objects) {
    const result = obj.intersect(ray);
    if (result && result.t < closest) {
      closest = result.t;
      hit = result;
    }
  }

  if (!hit) return { r: 135, g: 206, b: 235 }; // sky blue background

  const view = ray.dir.mul(-1);
  const { diffuse, specular } = phongLighting(hit.point, hit.normal, view, hit.object.specular);

  // Shadow
  const shadowRay = new Ray(hit.point.add(hit.normal.mul(1e-4)), light.position.sub(hit.point).norm());
  let inShadow = false;
  for (const obj of objects) {
    const shadowHit = obj.intersect(shadowRay);
    if (shadowHit) {
      inShadow = true;
      break;
    }
  }

  const localColor = hit.object.color;
  let color = {
    r: localColor.r * (inShadow ? 0.1 : (0.1 + diffuse)) + 255 * specular,
    g: localColor.g * (inShadow ? 0.1 : (0.1 + diffuse)) + 255 * specular,
    b: localColor.b * (inShadow ? 0.1 : (0.1 + diffuse)) + 255 * specular
  };

  // Reflection
  if (hit.object.reflective > 0) {
    const reflectDir = ray.dir.reflect(hit.normal).norm();
    const reflectRay = new Ray(hit.point.add(hit.normal.mul(1e-4)), reflectDir);
    const reflectColor = trace(reflectRay, depth + 1);
    color.r = color.r * (1 - hit.object.reflective) + reflectColor.r * hit.object.reflective;
    color.g = color.g * (1 - hit.object.reflective) + reflectColor.g * hit.object.reflective;
    color.b = color.b * (1 - hit.object.reflective) + reflectColor.b * hit.object.reflective;
  }

  return {
    r: Math.min(255, color.r),
    g: Math.min(255, color.g),
    b: Math.min(255, color.b)
  };
}

function render() {
  const image = ctx.getImageData(0, 0, width, height);
  const camera = new Vector(0, 0, 0);
  const fov = Math.PI / 3;

  for (let y = 0; y < height; y++) {
    const sy = 1 - 2 * y / height;
    for (let x = 0; x < width; x++) {
      const sx = 2 * x / width - 1;
      const dir = new Vector(sx * Math.tan(fov / 2) * width / height, sy * Math.tan(fov / 2), 1).norm();
      const ray = new Ray(camera, dir);
      const color = trace(ray, 0);
      const index = (y * width + x) * 4;
      image.data[index] = color.r;
      image.data[index + 1] = color.g;
      image.data[index + 2] = color.b;
      image.data[index + 3] = 255;
    }
  }

  ctx.putImageData(image, 0, 0);
}

render();
</script>
</body>
</html>
